#!/bin/bash

# Pre-commit hook to check for large code changes
# This script prevents large commits and encourages smaller, focused changes

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}üîç Checking commit size against main branch...${NC}"

# Check if we're on main branch
current_branch=$(git rev-parse --abbrev-ref HEAD)
if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
    echo -e "${GREEN}‚úÖ You're on the main branch. Commit allowed.${NC}"
    exit 0
fi

# Check if main branch exists, fallback to master
main_branch="main"
if ! git show-ref --verify --quiet refs/heads/main; then
    if git show-ref --verify --quiet refs/heads/master; then
        main_branch="master"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  No main or master branch found. Skipping size check.${NC}"
        exit 0
    fi
fi

# Get the merge base (common ancestor) with main
merge_base=$(git merge-base HEAD $main_branch 2>/dev/null)
if [ -z "$merge_base" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Cannot find common ancestor with $main_branch. Skipping size check.${NC}"
    exit 0
fi

# Check staged changes
staged_files=$(git diff --cached --name-only)
if [ -z "$staged_files" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  No staged changes found.${NC}"
    exit 0
fi

# Calculate diff statistics against main branch
# This includes both committed changes and staged changes
echo -e "${BLUE}üìä Analyzing changes since branching from $main_branch...${NC}"

# Extract line counts using git diff --numstat
committed_numstat=$(git diff --numstat $merge_base HEAD)
staged_numstat=$(git diff --cached --numstat)
combined_numstat=$(git diff --numstat --cached $merge_base)

# Calculate totals for committed changes only
committed_added=0
committed_removed=0
if [ ! -z "$committed_numstat" ]; then
    while IFS=$'\t' read -r added removed file; do
        if [[ "$added" =~ ^[0-9]+$ ]]; then
            committed_added=$((committed_added + added))
        fi
        if [[ "$removed" =~ ^[0-9]+$ ]]; then
            committed_removed=$((committed_removed + removed))
        fi
    done <<< "$committed_numstat"
fi

# Calculate totals for staged changes only
staged_added=0
staged_removed=0
if [ ! -z "$staged_numstat" ]; then
    while IFS=$'\t' read -r added removed file; do
        if [[ "$added" =~ ^[0-9]+$ ]]; then
            staged_added=$((staged_added + added))
        fi
        if [[ "$removed" =~ ^[0-9]+$ ]]; then
            staged_removed=$((staged_removed + removed))
        fi
    done <<< "$staged_numstat"
fi

# Calculate totals for ALL changes (this is the authoritative count - no double counting)
total_added=0
total_removed=0
if [ ! -z "$combined_numstat" ]; then
    while IFS=$'\t' read -r added removed file; do
        if [[ "$added" =~ ^[0-9]+$ ]]; then
            total_added=$((total_added + added))
        fi
        if [[ "$removed" =~ ^[0-9]+$ ]]; then
            total_removed=$((total_removed + removed))
        fi
    done <<< "$combined_numstat"
fi

# Calculate net changes
committed_net=$((committed_added - committed_removed))
staged_net=$((staged_added - staged_removed))
total_net=$((total_added - total_removed))

# Display statistics
echo -e "${BLUE}üìà Change Statistics:${NC}"
echo -e "  ${GREEN}Committed changes since $main_branch:${NC}"
echo -e "    Lines added: ${GREEN}+$committed_added${NC}"
echo -e "    Lines removed: ${RED}-$committed_removed${NC}"
echo -e "    Net change: $committed_net lines"
echo ""
echo -e "  ${YELLOW}Staged changes (about to commit):${NC}"
echo -e "    Lines added: ${GREEN}+$staged_added${NC}"
echo -e "    Lines removed: ${RED}-$staged_removed${NC}"
echo -e "    Net change: $staged_net lines"
echo ""
echo -e "  ${BLUE}Total branch changes (no double counting):${NC}"
echo -e "    Lines added: ${GREEN}+$total_added${NC}"
echo -e "    Lines removed: ${RED}-$total_removed${NC}"
echo -e "    Net change: $total_net lines"
echo -e "    ${BLUE}‚ÑπÔ∏è  Note: If files are modified in both committed and staged changes,${NC}"
echo -e "    ${BLUE}   they are counted only once in the total.${NC}"
echo ""

# Check if changes exceed threshold
THRESHOLD=100

# Check if either total added or removed lines exceed threshold
if [ $total_added -gt $THRESHOLD ] || [ $total_removed -gt $THRESHOLD ]; then
    echo -e "${RED}‚ö†Ô∏è  WARNING: Large code change detected!${NC}"
    echo -e "${YELLOW}Your branch has significant changes compared to $main_branch:${NC}"
    echo -e "  - Added lines: $total_added (threshold: $THRESHOLD)"
    echo -e "  - Removed lines: $total_removed (threshold: $THRESHOLD)"
    echo ""
    echo -e "${YELLOW}üí° Consider breaking your changes into smaller commits:${NC}"
    echo -e "  1. Split your changes into logical, focused commits"
    echo -e "  2. Each commit should represent a single concern or feature"
    echo -e "  3. Smaller commits are easier to review and debug"
    echo -e "  4. Consider using 'git add -p' for selective staging"
    echo ""
    
    # Prompt user
    echo -e "${YELLOW}Do you want to continue with this large commit? (y/N):${NC}"
    
    # Read response - this will work with both interactive and piped input
    if read -r response < /dev/tty 2>/dev/null; then
        # Successfully read from terminal
        echo "Response: $response"
    else
        # Fallback: try reading from stdin
        read -r response
        echo "Response: $response"
    fi
    
    case $response in
        [yY]|[yY][eE][sS])
            echo -e "${GREEN}‚úÖ Proceeding with commit...${NC}"
            exit 0
            ;;
        *)
            echo -e "${RED}‚ùå Commit aborted. Please consider breaking your changes into smaller commits.${NC}"
            echo -e "${BLUE}üí° Tip: Use 'git add -p' to stage parts of files selectively.${NC}"
            exit 1
            ;;
    esac
else
    echo -e "${GREEN}‚úÖ Change size looks good! (under $THRESHOLD lines threshold)${NC}"
    exit 0
fi
